# Part of the rstanjm package
# Copyright (C) 2015, 2016 Trustees of Columbia University
# Copyright (C) 2016 Sam Brilleman
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# Test if family object corresponds to a linear mixed model
#
# @param x A family object
is.lmer <- function(x) {
  if (!is(x, "family"))
    stop("x should be a family object.", call. = FALSE)
  isTRUE((x$family == "gaussian") && (x$link == "identity"))
}

# Split a 2D array into nsplits subarrays, returned as a list
#
# @param x A 2D array or matrix
# @param nsplits An integer, the number of subarrays or submatrices
# @param bycol A logical, if TRUE then the subarrays are generated by
#   splitting the columns of x
# @return A list of nsplits arrays or matrices
array2list <- function(x, nsplits, bycol = TRUE) {
  len <- if (bycol) ncol(x) else nrow(x)
  len_k <- len %/% nsplits 
  if (!len == (len_k * nsplits))
    stop("Dividing x by nsplits does not result in an integer.")
  lapply(1:nsplits, function(k) {
    if (bycol) x[, (k-1) * len_k + 1:len_k, drop = FALSE] else
      x[(k-1) * len_k + 1:len_k, , drop = FALSE]})
}

# Convert a standardised quadrature node to an unstandardised value based on 
# the specified integral limits
#
# @param x An unstandardised quadrature node
# @param a The lower limit(s) of the integral, possibly a vector
# @param b The upper limit(s) of the integral, possibly a vector
unstandardise_quadpoints <- function(x, a, b) {
  if (!identical(length(x), 1L) || !is.numeric(x))
    stop("'x' should be a single numeric value.", call. = FALSE)
  if (!all(is.numeric(a), is.numeric(b)))
    stop("'a' and 'b' should be numeric.", call. = FALSE)
  if (!length(a) %in% c(1L, length(b)))
    stop("'a' and 'b' should be vectors of length 1, or, be the same length.", call. = FALSE)
  if (any((b - a) < 0))
    stop("The upper limits for the integral ('b' values) should be greater than ",
         "the corresponding lower limits for the integral ('a' values).", call. = FALSE)
  ((b - a) / 2) * x + ((b + a) / 2)
}

# Convert a standardised quadrature weight to an unstandardised value based on 
# the specified integral limits
#
# @param x An unstandardised quadrature weight
# @param a The lower limit(s) of the integral, possibly a vector
# @param b The upper limit(s) of the integral, possibly a vector
unstandardise_quadweights <- function(x, a, b) {
  if (!identical(length(x), 1L) || !is.numeric(x))
    stop("'x' should be a single numeric value.", call. = FALSE)
  if (!all(is.numeric(a), is.numeric(b)))
    stop("'a' and 'b' should be numeric.", call. = FALSE)
  if (!length(a) %in% c(1L, length(b)))
    stop("'a' and 'b' should be vectors of length 1, or, be the same length.", call. = FALSE)
  if (any((b - a) < 0))
    stop("The upper limits for the integral ('b' values) should be greater than ",
         "the corresponding lower limits for the integral ('a' values).", call. = FALSE)
  ((b - a) / 2) * x
}

# Test if object is stanjm class
#
# @param x An object to be tested.
is.stanjm <- function(x) {
  is(x, "stanjm")
}

# Throw error if object isn't a stanjm object
# 
# @param x The object to test.
validate_stanjm_object <- function(x, call. = FALSE) {
  if (!is.stanjm(x))
    stop("Object is not a stanjm object.", call. = call.) 
}

# Throw error if parameter isn't a positive scalar
#
# @param x The object to test.
validate_positive_scalar <- function(x, not_greater_than = NULL) {
  nm <- deparse(substitute(x))
  if (is.null(x))
    stop(nm, " cannot be NULL", call. = FALSE)
  if (!is.numeric(x))
    stop(nm, " should be numeric", call. = FALSE)
  if (any(x <= 0)) 
    stop(nm, " should be postive", call. = FALSE)
  if (!is.null(not_greater_than)) {
    if (!is.numeric(not_greater_than) || (not_greater_than <= 0))
      stop("'not_greater_than' should be numeric and postive")
    if (!all(x <= not_greater_than))
      stop(nm, " should less than or equal to ", not_greater_than, call. = FALSE)
  }
}

# Return a list with the median and prob% CrI bounds for each column of a 
# matrix or 2D array
#
# @param x A matrix or 2D array
# @param prob Value between 0 and 1 indicating the desired width of the CrI
median_and_bounds <- function(x, prob) {
  if (!any(is.matrix(x), is.array(x)))
    stop("x should be a matrix or 2D array.")
  med <- apply(x, 2, median)
  lb  <- apply(x, 2, quantile, (1 - prob)/2)
  ub  <- apply(x, 2, quantile, (1 + prob)/2)
  nlist(med, lb, ub)
}

# Return the stub for variable names from one submodel of a stan_jm model
#
# @param m An integer specifying the number of the longitudinal submodel or
#   a character string specifying the submodel (e.g. "Long1", "Event", etc)
get_m_stub <- function(m) {
  if (is.null(m)) {
    return(NULL)
  } else if (is.numeric(m)) {
    return(paste0("Long", m, "|"))
  } else if (is.character(m)) {
    return(paste0(m, "|"))
  }
}

# Separates a names object into separate parts based on the longitudinal, 
# event, or association parameters.
# 
# @param x Character vector (often rownames(fit$stan_summary))
# @param M An integer specifying the number of longitudinal submodels.
# @param ... Arguments passed to grep
# @return A list with x separated out into those names corresponding
#   to parameters from the M longitudinal submodels, the event submodel
#   or association parameters.
collect_nms <- function(x, M, ...) {
  y <- lapply(1:M, function(m) grep(mod2rx(m), x, ...))
  y_extra <- lapply(1:M, function(m) 
    c(grep(paste0("^Long", m, "\\|sigma"), x, ...),
      grep(paste0("^Long", m, "\\|shape"), x, ...),
      grep(paste0("^Long", m, "\\|lambda"), x, ...),
      grep(paste0("^Long", m, "\\|reciprocal_dispersion"), x, ...)))             
  y <- lapply(1:M, function(m) setdiff(y[[m]], y_extra[[m]]))
  e <- grep(mod2rx("^Event"), x, ...)     
  e_extra <- c(grep("^Event\\|weibull-shape|^Event\\|basehaz-coef", x, ...))         
  e <- setdiff(e, e_extra)
  a <- grep(mod2rx("^Assoc"), x, ...)
  b <- b_names(x, ...)
  y_b <- lapply(1:M, function(m) b_names_M(x, m, ...))
  alpha <- grep("^.{5}\\|\\(Intercept\\)", x, ...)      
  beta <- setdiff(c(unlist(y), e, a), alpha)  
  nlist(y, y_extra, y_b, e, e_extra, a, b, alpha, beta) 
}

# Grep for "b" parameters (ranef), can optionally be specified
# for a specific longitudinal submodel
#
# @param x Character vector (often rownames(fit$stan_summary))
# @param submodel Optional integer specifying which long submodel
# @param ... Passed to grep
b_names_M <- function(x, submodel = NULL, ...) {
  if (is.null(submodel)) {
    grep("^b\\[", x, ...)
  } else {
    grep(paste0("^b\\[Long", submodel, "\\|"), x, ...)
  }
}

# Grep for regression coefs (fixef), can optionally be specified
# for a specific submodel
#
# @param x Character vector (often rownames(fit$stan_summary))
# @param submodel Character vector specifying which submodels
#   to obtain the coef names for. Can be "Long", "Event", "Assoc", or 
#   an integer specifying a specific longitudinal submodel. Specifying 
#   NULL selects all submodels.
# @param ... Passed to grep
beta_names <- function(x, submodel = NULL, ...) {
  if (is.null(submodel)) {
    rxlist <- c(mod2rx("^Long"), mod2rx("^Event"), mod2rx("^Assoc"))
  } else {
    rxlist <- c()
    if ("Long" %in% submodel) rxlist <- c(rxlist, mod2rx("^Long"))
    if ("Event" %in% submodel) rxlist <- c(rxlist, mod2rx("^Event"))
    if ("Assoc" %in% submodel) rxlist <- c(rxlist, mod2rx("^Assoc"))
    miss <- setdiff(submodel, c("Long", "Event", "Assoc"))
    if (length(miss)) rxlist <- c(rxlist, sapply(miss, mod2rx))
  }
  unlist(lapply(rxlist, function(y) grep(y, x, ...)))
}

# Converts "Long", "Event" or "Assoc" to the regular expression
# used at the start of variable names for the fitted joint model
#
# @param x The submodel for which the regular expression should be
#   obtained. Can be "Long", "Event", "Assoc", or an integer specifying
#   a specific longitudinal submodel.
mod2rx <- function(x) {
  if (x == "^Long") {
    c("^Long[1-9]\\|")
  } else if (x == "^Event") {
    c("^Event\\|")
  } else if (x == "^Assoc") {
    c("^Assoc\\|")
  } else if (x == "Long") {
    c("Long[1-9]\\|")
  } else if (x == "Event") {
    c("Event\\|")
  } else if (x == "Assoc") {
    c("Assoc\\|")
  } else {
    paste0("^Long", x, "\\|")
  }   
}

# Return the number of longitudinal submodels
#
# @param object A stanjm object
get_M <- function(object) {
  validate_stanjm_object(object)
  return(object$n_markers)
}

# Supplies names for the output list returned by most stanjm methods
#
# @param object The list object to which the names are to be applied
# @param M The number of longitudinal submodels. If NULL then the number of
#   longitudinal submodels is assumed to be equal to the length of object.
list_nms <- function(object, M = NULL) {
  if (!is.list(object)) 
    stop("'object' argument should be a list")
  if (is.null(M)) M <- length(object)
  nms <- paste0("Long", 1:M)
  if (length(object) > M) nms <- c(nms, "Event")
  names(object) <- nms
  object
}

# Removes the submodel identifying text (e.g. "Long1|", "Event|", etc 
# from variable names
#
# @param x Character vector (often rownames(fit$stan_summary)) from which
#   the stub should be removed
rm_stub <- function(x) {
  x <- gsub(mod2rx("Long"), "", x)
  x <- gsub(mod2rx("Event"), "", x)
}

# Removes a specified character string from the names of an
# object (for example, a matched call)
#
# @param x The matched call
# @param string The character string to be removed
strip_nms <- function(x, string) {
  names(x) <- gsub(string, "", names(x))
  x
}

# Check argument contains one of the allowed options
check_submodelopt2 <- function(x) {
  if (!x %in% c("long", "event"))
    stop("submodel option must be 'long' or 'event'") 
}
check_submodelopt3 <- function(x) {
  if (!x %in% c("long", "event", "both"))
    stop("submodel option must be 'long', 'event' or 'both'") 
}

# Error message when not specifying an argument required for stanjm objects
#
# @param arg The argument
STOP_arg_required_for_stanjm <- function(arg) {
  nm <- deparse(substitute(arg))
  stop(paste0("Argument '", nm, "' required for stanjm objects."))
}

# Error message when a function is not yet implemented for stanjm objects
#
# @param what A character string naming the function not yet implemented
STOP_if_stanjm <- function(what) {
  msg <- "not yet implemented for stanjm objects."
  if (!missing(what)) 
    msg <- paste(what, msg)
  stop(msg, call. = FALSE)
}

# Error message when a required variable is missing from the data frame
#
# @param var The name of the variable that could not be found
STOP_no_var <- function(var) {
  stop("Variable '", var, "' cannot be found in the data frame.", call. = FALSE)
}

# Extract parameters from stanmat and return as a list
# 
# @param object A stanjm object
# @param stanmat A matrix of posterior draws, may be provided if the desired 
#   stanmat is only a subset of the draws from as.matrix(object$stanfit)
# @return A named list
extract_pars <- function(object, stanmat = NULL, means = FALSE) {
  validate_stanjm_object(object)
  M <- get_M(object)
  if (is.null(stanmat)) 
    stanmat <- as.matrix(object$stanfit)
  nms   <- collect_nms(colnames(stanmat), M)
  if (!means) { # return array of posterior draws
    beta  <- lapply(1:M, function(m) stanmat[, nms$y[[m]], drop = FALSE])
    ebeta <- stanmat[, nms$e, drop = FALSE]
    abeta <- stanmat[, nms$a, drop = FALSE]
    bhcoef <- stanmat[, nms$e_extra, drop = FALSE]
    b     <- lapply(1:M, function(m) stanmat[, nms$y_b[[m]], drop = FALSE])
  } else { # return posterior means
    stanmat <- colMeans(stanmat)
    beta  <- lapply(1:M, function(m) stanmat[nms$y[[m]]])
    ebeta <- stanmat[nms$e]
    abeta <- stanmat[nms$a]
    bhcoef <- stanmat[nms$e_extra]
    b     <- lapply(1:M, function(m) stanmat[nms$yb[[m]]])
  }
  nlist(beta, ebeta, abeta, bhcoef, b)
}

# Validate newdataLong and newdataEvent arguments
#
# @param object A stanjm object
# @param newdataLong A data frame, or a list of data frames
# @param newdataEvent A data frame
# @param duplicate_ok A logical. If FALSE then only one row per individual is
#   allowed in the newdataEvent data frame
# @return A list of validated data frames
validate_newdatas <- function(object, newdataLong = NULL, newdataEvent = NULL,
                              duplicate_ok = FALSE) {
  validate_stanjm_object(object)
  id_var <- object$id_var
  newdatas <- list()
  if (!is.null(newdataLong)) {
    if (!is(newdataLong, "list"))
      newdataLong <- rep(list(newdataLong), get_M(object))
    newdatas <- c(newdatas, newdataLong)
  }
  if (!is.null(newdataEvent)) {
    if (!duplicate_ok && any(duplicated(newdataEvent[[id_var]])))
      stop("'newdataEvent' should only contain one row per individual, since ",
           "time varying covariates are not allowed in the prediction data.")
    newdatas <- c(newdatas, list(Event = newdataEvent))
  }
  newdatas <- lapply(newdatas, function(x) {
    if (!id_var %in% colnames(x)) STOP_no_var(id_var)
    validate_newdata(x)
  })
  ids <- lapply(newdatas, function(x) unique(x[[id_var]]))
  sorted_ids <- lapply(ids, sort)
  if (!length(unique(sorted_ids)) == 1L) 
    stop("The same subject ids should appear in each new data frame.")
  if (!length(unique(ids)) == 1L) 
    stop("The subject ids should be ordered the same in each new data frame.")  
  return(newdatas)
}

# Return data frames only including the specified subset of individuals
#
# @param object A stanjm object
# @param data A data frame, or a list of data frames
# @param ids A vector of ids indicating which individuals to keep
# @return A data frame, or a list of data frames, depending on the input
subset_ids <- function(object, data, ids) {
  validate_stanjm_object(object)
  id_var <- object$id_var
  is_list <- is(data, "list")
  if (!is_list) data <- list(data)
  is_df <- sapply(data, is.data.frame)
  if (!all(is_df)) stop("'data' should be a data frame, or list of data frames.")
  data <- lapply(data, function(x) {
    if (!id_var %in% colnames(x)) STOP_no_var(id_var)
    sel <- which(!ids %in% x[[id_var]])
    if (length(sel)) 
      stop("The following 'ids' do not appear in the data: ", 
           paste(ids[[sel]], collapse = ", "))
    x[x[[id_var]] %in% ids, , drop = FALSE]
  })
  if (is_list) return(data) else return(data[[1]])
}

# Check if individuals in ids argument were also used in model estimation
#
# @param object A stanjm object
# @param ids A vector of ids appearing in the pp data
# @param m Integer specifying which submodel to get the estimation IDs from
# @return A logical. TRUE indicates their are new ids in the prediction data,
#   while FALSE indicates all ids in the prediction data were used in fitting
#   the model. This return is used to determine whether to draw new b pars.
check_pp_ids <- function(object, ids, m = 1) {
  ids2 <- unique(model.frame(object, m = m)[[object$id_var]])
  if (any(ids %in% ids2))
    warning("Some of the IDs in the 'newdata' correspond to individuals in the ",
            "estimation dataset. Please be sure you want to obtain subject-",
            "specific predictions using the estimated random effects for those ",
            "individuals. If you instead meant to marginalise over the distribution ",
            "of the random effects, then please make sure the ID values do not ",
            "correspond to individuals in the estimation dataset.", immediate. = TRUE)
  if (!all(ids %in% ids2)) TRUE else FALSE
}

# Return log likelihood for full joint model
#
# @param ll_long A list with the log likelihood for each longitudinal submodel,
#   each element must be either: an S * Npat matrix (where S is the number of 
#   posterior draws used to calculate the log likelihood), a vector of length 
#   Npat, or a single value.  
# @param ll_event The log likelihood for the event submodel. Can be in any of  
#   the same forms as described for the ll_long argument.
# @param sum_ll A logical. If TRUE then the log likelihood is summed across all
#   individuals.
# @return Either a matrix, a vector or a scalar, depending on the input types
#   and whether sum_ll is set to TRUE.
ll_jm <- function(ll_long, ll_event, sum_ll = FALSE) {
  if (!is(ll_long, "list"))
    stop("'ll_long' should be a list.")
  ll_all <- c(ll_long, list(ll_event))
  if (is.matrix(ll_event)) { # inputs as matrices
    mats <- unique(sapply(ll_all, is.matrix))
    dims <- unique(sapply(ll_all, dim)) 
    if ((length(dims) > 1L) || (length(mats) > 1L))
      stop("Elements of 'll_long' should be the same class and dimension as 'll_event'.")
  } else { # inputs as vectors
    lens <- unique(sapply(ll_all, length))
    if (length(lens) > 1L)
      stop("Elements of 'll_long' should be the same length as 'll_event'.")
  }
  val <- Reduce('+', ll_all)
  if (!sum_ll) return(val) 
  else if (is.matrix(val)) return(rowSums(val)) 
  else return(sum(val))
}
