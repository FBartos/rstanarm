<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Prior distributions and options — priors • rstanarm</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">


<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>
  
  
<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">rstanarm</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Prior distributions and options</h1>
    </div>

    
    <p>The functions described on this page are used to specify the prior-related
arguments of the various modeling functions in the <span class="pkg">rstanarm</span> package (to
view the priors used for an existing model see <code><a href='prior_summary.stanreg.html'>prior_summary</a></code>). 
The default priors used in the various <span class="pkg">rstanarm</span> modeling functions are
intended to be <em>weakly informative</em> in that they provide moderate
regularlization and help stabilize computation. For many applications the
defaults will perform well, but prudent use of more informative priors is
encouraged. Uniform prior distributions are possible (e.g. by setting
<code><a href='stan_glm.html'>stan_glm</a></code>'s <code>prior</code> argument to <code>NULL</code>) but, unless
the data is very strong, they are not recommended and are <em>not</em>
non-informative, giving the same probability mass to implausible values as
plausible ones.</p>
    

    <pre class="usage"><span class='fu'>normal</span>(<span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>autoscale</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)

<span class='fu'>student_t</span>(<span class='kw'>df</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>autoscale</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)

<span class='fu'>cauchy</span>(<span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>autoscale</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)

<span class='fu'>hs</span>(<span class='kw'>df</span> <span class='kw'>=</span> <span class='fl'>3</span>, <span class='kw'>global_df</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>global_scale</span> <span class='kw'>=</span> <span class='fl'>1</span>)

<span class='fu'>hs_plus</span>(<span class='kw'>df1</span> <span class='kw'>=</span> <span class='fl'>3</span>, <span class='kw'>df2</span> <span class='kw'>=</span> <span class='fl'>3</span>, <span class='kw'>global_df</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>global_scale</span> <span class='kw'>=</span> <span class='fl'>1</span>)

<span class='fu'>laplace</span>(<span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>autoscale</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)

<span class='fu'>lasso</span>(<span class='kw'>df</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>autoscale</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)

<span class='fu'>product_normal</span>(<span class='kw'>df</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='fl'>1</span>)

<span class='fu'>exponential</span>(<span class='kw'>rate</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>autoscale</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)

<span class='fu'>decov</span>(<span class='kw'>regularization</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>concentration</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>shape</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='fl'>1</span>)

<span class='fu'>dirichlet</span>(<span class='kw'>concentration</span> <span class='kw'>=</span> <span class='fl'>1</span>)

<span class='fu'>R2</span>(<span class='kw'>location</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>what</span> <span class='kw'>=</span> <span class='fu'>c</span>(<span class='st'>"mode"</span>, <span class='st'>"mean"</span>, <span class='st'>"median"</span>, <span class='st'>"log"</span>))</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a> Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>location</th>
      <td><p>Prior location. In most cases, this is the prior mean, but
for <code>cauchy</code> (which is equivalent to <code>student_t</code> with
<code>df=1</code>), the mean does not exist and <code>location</code> is the prior
median. The default value is \(0\), except for <code>R2</code> which has no
default value for <code>location</code>. For <code>R2</code>, <code>location</code> pertains
to the prior location of the \(R^2\) under a Beta distribution, but the
interpretation of the <code>location</code> parameter depends on the specified
value of the <code>what</code> argument (see the <em>R2 family</em> section in
<strong>Details</strong>).</p></td>
    </tr>
    <tr>
      <th>scale</th>
      <td><p>Prior scale. The default depends on the family (see
<strong>Details</strong>).</p></td>
    </tr>
    <tr>
      <th>autoscale</th>
      <td><p>A logical scalar, defaulting to <code>TRUE</code>. If <code>TRUE</code> 
then the scales of the priors on the intercept and regression coefficients 
may be additionally modified internally by <span class="pkg">rstanarm</span> in the following 
cases. First, for Gaussian models only, the prior scales for the intercept, 
coefficients, and the auxiliary parameter <code>sigma</code> (error standard 
deviation) are multiplied by <code>sd(y)</code>. Additionally --- not only for 
Gaussian models --- if the <code>QR</code> argument to the model fitting function
(e.g. <code>stan_glm</code>) is <code>FALSE</code> then: for a predictor with only one 
value nothing is changed; for a predictor <code>x</code> with exactly two unique 
values, we take the user-specified (or default) scale(s) for the selected 
priors and divide by the range of <code>x</code>; for a predictor <code>x</code> with 
more than two unique values, we divide the prior scale(s) by <code>sd(x)</code>.</p></td>
    </tr>
    <tr>
      <th>df, df1, df2</th>
      <td><p>Prior degrees of freedom. The default is \(1\) for 
<code>student_t</code>, in which case it is equivalent to <code>cauchy</code>. For the 
hierarchical shrinkage priors (<code>hs</code> and <code>hs_plus</code>) the degrees of
freedom parameter(s) default to \(3\). For the <code>product_normal</code> 
prior, the degrees of freedom parameter must be an integer (vector) that is
at least \(2\) (the default).</p></td>
    </tr>
    <tr>
      <th>global_df, global_scale</th>
      <td><p>Optional arguments for the hierarchical
shrinkage priors. See the <em>Hierarchical shrinkage family</em> section
below.</p></td>
    </tr>
    <tr>
      <th>rate</th>
      <td><p>Prior rate for the exponential distribution. Defaults to
<code>1</code>. For the exponential distribution, the rate parameter is the
<em>reciprocal</em> of the mean.</p></td>
    </tr>
    <tr>
      <th>regularization</th>
      <td><p>Exponent for an LKJ prior on the correlation matrix in
the <code>decov</code> prior. The default is \(1\), implying a joint uniform
prior.</p></td>
    </tr>
    <tr>
      <th>concentration</th>
      <td><p>Concentration parameter for a symmetric Dirichlet 
distribution. The default is \(1\), implying a joint uniform prior.</p></td>
    </tr>
    <tr>
      <th>shape</th>
      <td><p>Shape parameter for a gamma prior on the scale parameter in the
<code>decov</code> prior. If <code>shape</code> and <code>scale</code> are both \(1\) (the
default) then the gamma prior simplifies to the unit-exponential
distribution.</p></td>
    </tr>
    <tr>
      <th>what</th>
      <td><p>A character string among <code>'mode'</code> (the default),
<code>'mean'</code>, <code>'median'</code>, or <code>'log'</code> indicating how the
<code>location</code> parameter is interpreted in the <code>LKJ</code> case. If
<code>'log'</code>, then <code>location</code> is interpreted as the expected
logarithm of the \(R^2\) under a Beta distribution. Otherwise,
<code>location</code> is interpreted as the <code>what</code> of the \(R^2\)
under a Beta distribution. If the number of predictors is less than
or equal to two, the mode of this Beta distribution does not exist
and an error will prompt the user to specify another choice for
<code>what</code>.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>A named list to be used internally by the <span class="pkg">rstanarm</span> model
  fitting functions.</p>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>The details depend on the family of the prior being used:</p><h3>Student t family</h3>
    Family members:
  <ul>
<li><p><code>normal(location, scale)</code></p></li>
<li><p><code>student_t(df, location, scale)</code></p></li>
<li><p><code>cauchy(location, scale)</code></p></li>
</ul>
  Each of these functions also takes an argument <code>autoscale</code>.
    For the prior distribution for the intercept, <code>location</code>, 
  <code>scale</code>, and <code>df</code> should be scalars. For the prior for the other
  coefficients they can either be vectors of length equal to the number of
  coefficients (not including the intercept), or they can be scalars, in 
  which case they will be recycled to the appropriate length. As the 
  degrees of freedom approaches infinity, the Student t distribution 
  approaches the normal distribution and if the degrees of freedom are one,
  then the Student t distribution is the Cauchy distribution.
    If <code>scale</code> is not specified it will default to \(10\) for the
  intercept and \(2.5\) for the other coefficients, unless the probit link
  function is used, in which case these defaults are scaled by a factor of 
  <code>dnorm(0)/dlogis(0)</code>, which is roughly \(1.6\).
    If the <code>autoscale</code> argument is <code>TRUE</code> (the default), then the 
  scales will be further adjusted as described above in the documentation of 
  the <code>autoscale</code> argument in the <strong>Arguments</strong> section.
    <h3>Hierarchical shrinkage family</h3>
    Family members:
  <ul>
<li><p><code>hs(df, global_df, global_scale)</code></p></li>
<li><p><code>hs_plus(df1, df2, global_df, global_scale)</code></p></li>
</ul>
    The hierarchical shrinkage priors are normal with a mean of zero and a 
  standard deviation that is also a random variable. The traditional 
  hierarchical shrinkage prior utilizes a standard deviation that is 
  distributed half Cauchy with a median of zero and a scale parameter that is
  also half Cauchy. This is called the "horseshoe prior". The hierarchical 
  shrinkage (<code>hs</code>) prior in the <span class="pkg">rstanarm</span> package instead utilizes 
  a half Student t distribution for the standard deviation (with 3 degrees of
  freedom by default), as described by Piironen and Vehtari (2015). It is
  possible to change the <code>df</code> argument, the prior degrees of freedom, to
  obtain less or more shrinkage. Traditionally the standard deviation
  parameter is then scaled by the square root of a <em>global</em> half Cauchy 
  parameter, although <span class="pkg">rstanarm</span> allows setting <code>global_df</code> and 
  <code>global_scale</code> arguments, in which case this global parameter is 
  distributed half Student t with degrees of freedom <code>global_df</code> and 
  scale <code>global_scale</code>.
    The hierarhical shrinkpage plus (<code>hs_plus</code>) prior is a normal with a 
  mean of zero and a standard deviation that is distributed as the product of
  two independent half Student t parameters (both with \(3\) degrees of
  freedom (<code>df1</code>, <code>df2</code>) by default) that are each scaled in a
  similar way to the <code>hs</code> prior.
    The hierarchical shrinkage priors have very tall modes and very fat tails.
  Consequently, they tend to produce posterior distributions that are very
  concentrated near zero, unless the predictor has a strong influence on the
  outcome, in which case the prior has little influence. Hierarchical 
  shrinkage priors often require you to increase the 
  <code><a href='adapt_delta.html'>adapt_delta</a></code> tuning parameter in order to diminish the number 
  of divergent transitions. For more details on tuning parameters and 
  divergent transitions see the Troubleshooting section of the <em>How to
  Use the rstanarm Package</em> vignette.
    <h3>Laplace family</h3>
    Family members:
  <ul>
<li><p><code>laplace(location, scale)</code></p></li>
<li><p><code>lasso(df, location, scale)</code></p></li>
</ul>
  Each of these functions also takes an argument <code>autoscale</code>.
    The Laplace distribution is also known as the double-exponential 
  distribution. It is a symmetric distribution with a sharp peak at its mean 
  / median / mode and fairly long tails. This distribution can be motivated 
  as a scale mixture of normal distributions and the remarks above about the 
  normal distribution apply here as well.
    The lasso approach to supervised learning can be expressed as finding the
  posterior mode when the likelihood is Gaussian and the priors on the 
  coefficients have independent Laplace distributions. It is commonplace in
  supervised learning to choose the tuning parameter by cross-validation,
  whereas a more Bayesian approach would be to place a prior on &#8220;it&#8221;,
  or rather its reciprocal in our case (i.e. <em>smaller</em> values correspond
  to more shrinkage toward the prior location vector). We use a chi-square
  prior with degrees of freedom equal to that specified in the call to
  <code>lasso</code> or, by default, 1. The expectation of a chi-square random
  variable is equal to this degrees of freedom and the mode is equal to the
  degrees of freedom minus 2, if this difference is positive.
    It is also common in supervised learning to standardize the predictors 
  before training the model. We do not recommend doing so. Instead, it is
  better to specify <code>autoscale = TRUE</code> (the default value), which 
  will adjust the scales of the priors according to the dispersion in the
  variables. See the documentation of the <code>autoscale</code> argument above 
  and also the <code><a href='prior_summary.stanreg.html'>prior_summary</a></code> page for more information.
    <h3>Product-normal family</h3>
    Family members:
  <ul>
<li><p><code>product_normal(df, location, scale)</code></p></li>
</ul>
  The product-normal distribution is the product of at least two independent 
  normal variates each with mean zero, shifted by the <code>location</code>
  parameter. It can be shown that the density of a product-normal variate is
  symmetric and infinite at <code>location</code>, so this prior resembles a
  &#8220;spike-and-slab&#8221; prior for sufficiently large values of the
  <code>scale</code> parameter. For better or for worse, this prior may be
  appropriate when it is strongly believed (by someone) that a regression
  coefficient &#8220;is&#8221; equal to the <code>location</code>, parameter even though
  no true Bayesian would specify such a prior.
    Each element of <code>df</code> must be an integer of at least \(2\) because
  these &#8220;degrees of freedom&#8221; are interpreted as the number of normal
  variates being multiplied and then shifted by <code>location</code> to yield the
  regression coefficient. Higher degrees of freedom produce a sharper
  spike at <code>location</code>.
    Each element of <code>scale</code> must be a non-negative real number that is
  interpreted as the standard deviation of the normal variates being
  multiplied and then shifted by <code>location</code> to yield the regression
  coefficient. In other words, the elements of <code>scale</code> may differ, but
  the k-th standard deviation is presumed to hold for all the normal deviates
  that are multiplied together and shifted by the k-th element of
  <code>location</code> to yield the k-th regression coefficient. The elements of 
  <code>scale</code> are not the prior standard deviations of the regression
  coefficients. The prior variance of the regression coefficients is equal to
  the scale raised to the power of \(2\) times the corresponding element of
  <code>df</code>. Thus, larger values of <code>scale</code> put more prior volume on
  values of the regression coefficient that are far from zero.
    <h3>Dirichlet family</h3>
    Family members:
  <ul>
<li><p><code>dirichlet(concentration)</code></p></li>
</ul>
    The Dirichlet distribution is a multivariate generalization of the beta
  distribution. It is perhaps the easiest prior distribution to specify
  because the concentration parameters can be interpreted as prior counts
  (although they need not be integers) of a multinomial random variable.
    The Dirichlet distribution is used in <code><a href='stan_polr.html'>stan_polr</a></code> for an 
  implicit prior on the cutpoints in an ordinal regression model. More
  specifically, the Dirichlet prior pertains to the prior probability of
  observing each category of the ordinal outcome when the predictors are at
  their sample means. Given these prior probabilities, it is straightforward
  to add them to form cumulative probabilities and then use an inverse CDF
  transformation of the cumulative probabilities to define the cutpoints.
    If a scalar is passed to the <code>concentration</code> argument of the 
  <code>dirichlet</code> function, then it is replicated to the appropriate length 
  and the Dirichlet distribution is symmetric. If <code>concentration</code> is a
  vector and all elements are \(1\), then the Dirichlet distribution is
  jointly uniform. If all concentration parameters are equal but greater than
  \(1\) then the prior mode is that the categories are equiprobable, and
  the larger the value of the identical concentration parameters, the more
  sharply peaked the distribution is at the mode. The elements in 
  <code>concentration</code> can also be given different values to represent that 
  not all outcome categories are a priori equiprobable.
    <h3>Covariance matrices</h3>
    Family members:
  <ul>
<li><p><code>decov(regularization, concentration, shape, scale)</code></p></li>
</ul>
  (Also see vignette for <code>stan_glmer</code>)
    Covariance matrices are decomposed into correlation matrices and 
  variances. The variances are in turn decomposed into the product of a
  simplex vector and the trace of the matrix. Finally, the trace is the
  product of the order of the matrix and the square of a scale parameter.
  This prior on a covariance matrix is represented by the <code>decov</code> 
  function.
    The prior for a correlation matrix is called LKJ whose density is 
  proportional to the determinant of the correlation matrix raised to the 
  power of a positive regularization parameter minus one. If
  <code>regularization = 1</code> (the default), then this prior is jointly 
  uniform over all correlation matrices of that size. If 
  <code>regularization &gt; 1</code>, then the identity matrix is the mode and in the
  unlikely case that <code>regularization &lt; 1</code>, the identity matrix is the
  trough.
    The trace of a covariance matrix is equal to the sum of the variances. We
  set the trace equal to the product of the order of the covariance matrix
  and the <em>square</em> of a positive scale parameter. The particular
  variances are set equal to the product of a simplex vector --- which is
  non-negative and sums to \(1\) --- and the scalar trace. In other words,
  each element of the simplex vector represents the proportion of the trace
  attributable to the corresponding variable.
    A symmetric Dirichlet prior is used for the simplex vector, which has a 
  single (positive) <code>concentration</code> parameter, which defaults to
  \(1\) and implies that the prior is jointly uniform over the space of
  simplex vectors of that size. If <code>concentration &gt; 1</code>, then the prior
  mode corresponds to all variables having the same (proportion of total)
  variance, which can be used to ensure the the posterior variances are not
  zero. As the <code>concentration</code> parameter approaches infinity, this
  mode becomes more pronounced. In the unlikely case that 
  <code>concentration &lt; 1</code>, the variances are more polarized.
    If all the variables were multiplied by a number, the trace of their 
  covariance matrix would increase by that number squared. Thus, it is 
  reasonable to use a scale-invariant prior distribution for the positive
  scale parameter, and in this case we utilize a Gamma distribution, whose
  <code>shape</code> and <code>scale</code> are both \(1\) by default, implying a
  unit-exponential distribution. Set the <code>shape</code> hyperparameter to some
  value greater than \(1\) to ensure that the posterior trace is not zero.
    If <code>regularization</code>, <code>concentration</code>, <code>shape</code> and / or 
  <code>scale</code> are positive scalars, then they are recycled to the 
  appropriate length. Otherwise, each can be a positive vector of the 
  appropriate length, but the appropriate length depends on the number of 
  covariance matrices in the model and their sizes. A one-by-one covariance 
  matrix is just a variance and thus does not have <code>regularization</code> or 
  <code>concentration</code> parameters, but does have <code>shape</code> and 
  <code>scale</code> parameters for the prior standard deviation of that 
  variable.
    <h3>R2 family</h3>
    Family members:
  <ul>
<li><p><code>R2(location, what)</code></p></li>
</ul>
    The <code><a href='stan_lm.html'>stan_lm</a></code>, <code><a href='stan_lm.html'>stan_aov</a></code>, and 
  <code><a href='stan_polr.html'>stan_polr</a></code> functions allow the user to utilize a function 
  called <code>R2</code> to convey prior information about all the parameters. 
  This prior hinges on prior beliefs about the location of \(R^2\), the 
  proportion of variance in the outcome attributable to the predictors, 
  which has a <code><a href='http://www.rdocumentation.org/packages/stats/topics/Beta'>Beta</a></code> prior with first shape 
  hyperparameter equal to half the number of predictors and second shape 
  hyperparameter free. By specifying <code>what</code> to be the prior mode (the
  default), mean, median, or expected log of \(R^2\), the second shape
  parameter for this Beta distribution is determined internally. If
  <code>what = 'log'</code>, location should be a negative scalar; otherwise it
  should be a scalar on the \((0,1)\) interval.
    For example, if \(R^2 = 0.5\), then the mode, mean, and median of
  the <code><a href='http://www.rdocumentation.org/packages/stats/topics/Beta'>Beta</a></code> distribution are all the same and thus the
  second shape parameter is also equal to half the number of predictors.
  The second shape parameter of the <code><a href='http://www.rdocumentation.org/packages/stats/topics/Beta'>Beta</a></code> distribution
  is actually the same as the shape parameter in the LKJ prior for a
  correlation matrix described in the previous subsection. Thus, the smaller 
  is \(R^2\), the larger is the shape parameter, the smaller are the
  prior correlations among the outcome and predictor variables, and the more
  concentrated near zero is the prior density for the regression 
  coefficients. Hence, the prior on the coefficients is regularizing and 
  should yield a posterior distribution with good out-of-sample predictions 
  <em>if</em> the prior location of \(R^2\) is specified in a reasonable 
  fashion.
    
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
  A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
  Press, London, third edition. <a href = 'http://stat.columbia.edu/~gelman/book/'>http://stat.columbia.edu/~gelman/book/</a></p>
<p>Gelman, A., Jakulin, A., Pittau, M. G., and Su, Y. (2008). A weakly
informative default prior distribution for logistic and other regression
models. <em>Annals of Applied Statistics</em>. 2(4), 1360--1383.</p>
<p>Piironen, J., and Vehtari, A. (2015). Projection predictive variable
selection using Stan+R. <a href = 'http://arxiv.org/abs/1508.02502/'>http://arxiv.org/abs/1508.02502/</a></p>
<p>Stan Development Team. (2016). <em>Stan Modeling Language Users Guide and
Reference Manual.</em> <a href = 'http://mc-stan.org/documentation/'>http://mc-stan.org/documentation/</a></p>
    
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <p>The various vignettes for the <span class="pkg">rstanarm</span> package also discuss 
  and demonstrate the use of some of the supported prior distributions.</p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='no'>fmla</span> <span class='kw'>&lt;-</span> <span class='no'>mpg</span> ~ <span class='no'>wt</span> + <span class='no'>qsec</span> + <span class='no'>drat</span> + <span class='no'>am</span>

<span class='co'># Draw from prior predictive distribution (by setting prior_PD = TRUE)</span>
<span class='no'>prior_pred_fit</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='stan_glm.html'>stan_glm</a></span>(<span class='no'>fmla</span>, <span class='kw'>data</span> <span class='kw'>=</span> <span class='no'>mtcars</span>, <span class='kw'>prior_PD</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
                           <span class='kw'>chains</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>seed</span> <span class='kw'>=</span> <span class='fl'>12345</span>, <span class='kw'>iter</span> <span class='kw'>=</span> <span class='fl'>250</span>, <span class='co'># for speed only</span>
                           <span class='kw'>prior</span> <span class='kw'>=</span> <span class='fu'>student_t</span>(<span class='kw'>df</span> <span class='kw'>=</span> <span class='fl'>4</span>, <span class='fl'>0</span>, <span class='fl'>2.5</span>),
                           <span class='kw'>prior_intercept</span> <span class='kw'>=</span> <span class='fu'>cauchy</span>(<span class='fl'>0</span>,<span class='fl'>10</span>),
                           <span class='kw'>prior_aux</span> <span class='kw'>=</span> <span class='fu'>exponential</span>(<span class='fl'>1</span>/<span class='fl'>2</span>))</div><div class='output co'>#&gt; 
#&gt; SAMPLING FOR MODEL 'continuous' NOW (CHAIN 1).
#&gt; WARNING: The initial buffer, adaptation window, and terminal buffer
#&gt;          overflow the total number of warmup iterations.
#&gt;          Defaulting to a 15%/75%/10% partition,
#&gt;            init_buffer = 18
#&gt;            adapt_window = 95
#&gt;            term_buffer = 12
#&gt; 
#&gt; 
#&gt; Chain 1, Iteration:   1 / 250 [  0%]  (Warmup)
#&gt; Chain 1, Iteration:  25 / 250 [ 10%]  (Warmup)
#&gt; Chain 1, Iteration:  50 / 250 [ 20%]  (Warmup)
#&gt; Chain 1, Iteration:  75 / 250 [ 30%]  (Warmup)
#&gt; Chain 1, Iteration: 100 / 250 [ 40%]  (Warmup)
#&gt; Chain 1, Iteration: 125 / 250 [ 50%]  (Warmup)
#&gt; Chain 1, Iteration: 126 / 250 [ 50%]  (Sampling)
#&gt; Chain 1, Iteration: 150 / 250 [ 60%]  (Sampling)
#&gt; Chain 1, Iteration: 175 / 250 [ 70%]  (Sampling)
#&gt; Chain 1, Iteration: 200 / 250 [ 80%]  (Sampling)
#&gt; Chain 1, Iteration: 225 / 250 [ 90%]  (Sampling)
#&gt; Chain 1, Iteration: 250 / 250 [100%]  (Sampling)
#&gt;  Elapsed Time: 0.049511 seconds (Warm-up)
#&gt;                0.190989 seconds (Sampling)
#&gt;                0.2405 seconds (Total)
#&gt; </div><div class='output co'>#&gt; <span class='warning'>Warning: Markov chains did not converge! Do not analyze results!</span></div><div class='input'><span class='fu'>plot</span>(<span class='no'>prior_pred_fit</span>, <span class='st'>"hist"</span>)</div><div class='output co'>#&gt; <span class='message'>`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</span></div><img src='priors-6.png' alt='' width='540' height='400' /><div class='input'>

<span class='co'># Can assign priors to names</span>
<span class='no'>N05</span> <span class='kw'>&lt;-</span> <span class='fu'>normal</span>(<span class='fl'>0</span>, <span class='fl'>5</span>)
<span class='no'>fit</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='stan_glm.html'>stan_glm</a></span>(<span class='no'>fmla</span>, <span class='kw'>data</span> <span class='kw'>=</span> <span class='no'>mtcars</span>, <span class='kw'>prior</span> <span class='kw'>=</span> <span class='no'>N05</span>, <span class='kw'>prior_intercept</span> <span class='kw'>=</span> <span class='no'>N05</span>)</div><div class='output co'>#&gt; 
#&gt; SAMPLING FOR MODEL 'continuous' NOW (CHAIN 1).
#&gt; 
#&gt; Chain 1, Iteration:    1 / 2000 [  0%]  (Warmup)
#&gt; Chain 1, Iteration:  200 / 2000 [ 10%]  (Warmup)
#&gt; Chain 1, Iteration:  400 / 2000 [ 20%]  (Warmup)
#&gt; Chain 1, Iteration:  600 / 2000 [ 30%]  (Warmup)
#&gt; Chain 1, Iteration:  800 / 2000 [ 40%]  (Warmup)
#&gt; Chain 1, Iteration: 1000 / 2000 [ 50%]  (Warmup)
#&gt; Chain 1, Iteration: 1001 / 2000 [ 50%]  (Sampling)
#&gt; Chain 1, Iteration: 1200 / 2000 [ 60%]  (Sampling)
#&gt; Chain 1, Iteration: 1400 / 2000 [ 70%]  (Sampling)
#&gt; Chain 1, Iteration: 1600 / 2000 [ 80%]  (Sampling)
#&gt; Chain 1, Iteration: 1800 / 2000 [ 90%]  (Sampling)
#&gt; Chain 1, Iteration: 2000 / 2000 [100%]  (Sampling)
#&gt;  Elapsed Time: 0.622004 seconds (Warm-up)
#&gt;                0.093617 seconds (Sampling)
#&gt;                0.715621 seconds (Total)
#&gt; 
#&gt; 
#&gt; SAMPLING FOR MODEL 'continuous' NOW (CHAIN 2).
#&gt; 
#&gt; Chain 2, Iteration:    1 / 2000 [  0%]  (Warmup)
#&gt; Chain 2, Iteration:  200 / 2000 [ 10%]  (Warmup)
#&gt; Chain 2, Iteration:  400 / 2000 [ 20%]  (Warmup)
#&gt; Chain 2, Iteration:  600 / 2000 [ 30%]  (Warmup)
#&gt; Chain 2, Iteration:  800 / 2000 [ 40%]  (Warmup)
#&gt; Chain 2, Iteration: 1000 / 2000 [ 50%]  (Warmup)
#&gt; Chain 2, Iteration: 1001 / 2000 [ 50%]  (Sampling)
#&gt; Chain 2, Iteration: 1200 / 2000 [ 60%]  (Sampling)
#&gt; Chain 2, Iteration: 1400 / 2000 [ 70%]  (Sampling)
#&gt; Chain 2, Iteration: 1600 / 2000 [ 80%]  (Sampling)
#&gt; Chain 2, Iteration: 1800 / 2000 [ 90%]  (Sampling)
#&gt; Chain 2, Iteration: 2000 / 2000 [100%]  (Sampling)
#&gt;  Elapsed Time: 0.102608 seconds (Warm-up)
#&gt;                0.088717 seconds (Sampling)
#&gt;                0.191325 seconds (Total)
#&gt; 
#&gt; 
#&gt; SAMPLING FOR MODEL 'continuous' NOW (CHAIN 3).
#&gt; 
#&gt; Chain 3, Iteration:    1 / 2000 [  0%]  (Warmup)
#&gt; Chain 3, Iteration:  200 / 2000 [ 10%]  (Warmup)
#&gt; Chain 3, Iteration:  400 / 2000 [ 20%]  (Warmup)
#&gt; Chain 3, Iteration:  600 / 2000 [ 30%]  (Warmup)
#&gt; Chain 3, Iteration:  800 / 2000 [ 40%]  (Warmup)
#&gt; Chain 3, Iteration: 1000 / 2000 [ 50%]  (Warmup)
#&gt; Chain 3, Iteration: 1001 / 2000 [ 50%]  (Sampling)
#&gt; Chain 3, Iteration: 1200 / 2000 [ 60%]  (Sampling)
#&gt; Chain 3, Iteration: 1400 / 2000 [ 70%]  (Sampling)
#&gt; Chain 3, Iteration: 1600 / 2000 [ 80%]  (Sampling)
#&gt; Chain 3, Iteration: 1800 / 2000 [ 90%]  (Sampling)
#&gt; Chain 3, Iteration: 2000 / 2000 [100%]  (Sampling)
#&gt;  Elapsed Time: 0.108546 seconds (Warm-up)
#&gt;                0.098502 seconds (Sampling)
#&gt;                0.207048 seconds (Total)
#&gt; 
#&gt; 
#&gt; SAMPLING FOR MODEL 'continuous' NOW (CHAIN 4).
#&gt; 
#&gt; Chain 4, Iteration:    1 / 2000 [  0%]  (Warmup)
#&gt; Chain 4, Iteration:  200 / 2000 [ 10%]  (Warmup)
#&gt; Chain 4, Iteration:  400 / 2000 [ 20%]  (Warmup)
#&gt; Chain 4, Iteration:  600 / 2000 [ 30%]  (Warmup)
#&gt; Chain 4, Iteration:  800 / 2000 [ 40%]  (Warmup)
#&gt; Chain 4, Iteration: 1000 / 2000 [ 50%]  (Warmup)
#&gt; Chain 4, Iteration: 1001 / 2000 [ 50%]  (Sampling)
#&gt; Chain 4, Iteration: 1200 / 2000 [ 60%]  (Sampling)
#&gt; Chain 4, Iteration: 1400 / 2000 [ 70%]  (Sampling)
#&gt; Chain 4, Iteration: 1600 / 2000 [ 80%]  (Sampling)
#&gt; Chain 4, Iteration: 1800 / 2000 [ 90%]  (Sampling)
#&gt; Chain 4, Iteration: 2000 / 2000 [100%]  (Sampling)
#&gt;  Elapsed Time: 0.116916 seconds (Warm-up)
#&gt;                0.105358 seconds (Sampling)
#&gt;                0.222274 seconds (Total)
#&gt; </div><div class='input'>

<span class='co'># Visually compare normal, student_t, cauchy, laplace, and product_normal</span>
<span class='no'>compare_priors</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>scale</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='no'>df_t</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='no'>xlim</span> <span class='kw'>=</span> <span class='fu'>c</span>(-<span class='fl'>10</span>, <span class='fl'>10</span>)) {
  <span class='no'>dt_loc_scale</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>x</span>, <span class='no'>df</span>, <span class='no'>location</span>, <span class='no'>scale</span>) {
    <span class='fl'>1</span>/<span class='no'>scale</span> * <span class='fu'>dt</span>((<span class='no'>x</span> - <span class='no'>location</span>)/<span class='no'>scale</span>, <span class='no'>df</span>)
  }
  <span class='no'>dlaplace</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>x</span>, <span class='no'>location</span>, <span class='no'>scale</span>) {
    <span class='fl'>0.5</span> / <span class='no'>scale</span> * <span class='fu'>exp</span>(-<span class='fu'>abs</span>(<span class='no'>x</span> - <span class='no'>location</span>) / <span class='no'>scale</span>)
  }
  <span class='no'>dproduct_normal</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>x</span>, <span class='no'>scale</span>) {
    <span class='fu'>besselK</span>(<span class='fu'>abs</span>(<span class='no'>x</span>) / <span class='no'>scale</span> ^ <span class='fl'>2</span>, <span class='kw'>nu</span> <span class='kw'>=</span> <span class='fl'>0</span>) / (<span class='no'>scale</span> ^ <span class='fl'>2</span> * <span class='no'>pi</span>)
  }
  <span class='no'>stat_dist</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>dist</span>, <span class='no'>...</span>) {
    <span class='kw'>ggplot2</span><span class='kw'>::</span><span class='fu'>stat_function</span>(<span class='kw'>ggplot2</span><span class='kw'>::</span><span class='fu'>aes_</span>(<span class='kw'>color</span> <span class='kw'>=</span> <span class='no'>dist</span>), <span class='no'>...</span>)
  }
  <span class='kw'>ggplot2</span><span class='kw'>::</span><span class='fu'>ggplot</span>(<span class='fu'>data.frame</span>(<span class='kw'>x</span> <span class='kw'>=</span> <span class='no'>xlim</span>), <span class='kw'>ggplot2</span><span class='kw'>::</span><span class='fu'>aes</span>(<span class='no'>x</span>)) +
    <span class='fu'>stat_dist</span>(<span class='st'>"normal"</span>, <span class='kw'>size</span> <span class='kw'>=</span> <span class='fl'>.75</span>, <span class='kw'>fun</span> <span class='kw'>=</span> <span class='no'>dnorm</span>,
              <span class='kw'>args</span> <span class='kw'>=</span> <span class='fu'>list</span>(<span class='kw'>mean</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>sd</span> <span class='kw'>=</span> <span class='no'>scale</span>)) +
    <span class='fu'>stat_dist</span>(<span class='st'>"student_t"</span>, <span class='kw'>size</span> <span class='kw'>=</span> <span class='fl'>.75</span>, <span class='kw'>fun</span> <span class='kw'>=</span> <span class='no'>dt_loc_scale</span>,
              <span class='kw'>args</span> <span class='kw'>=</span> <span class='fu'>list</span>(<span class='kw'>df</span> <span class='kw'>=</span> <span class='no'>df_t</span>, <span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='no'>scale</span>)) +
    <span class='fu'>stat_dist</span>(<span class='st'>"cauchy"</span>, <span class='kw'>size</span> <span class='kw'>=</span> <span class='fl'>.75</span>, <span class='kw'>linetype</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>fun</span> <span class='kw'>=</span> <span class='no'>dcauchy</span>,
              <span class='kw'>args</span> <span class='kw'>=</span> <span class='fu'>list</span>(<span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='no'>scale</span>)) +
    <span class='fu'>stat_dist</span>(<span class='st'>"laplace"</span>, <span class='kw'>size</span> <span class='kw'>=</span> <span class='fl'>.75</span>, <span class='kw'>linetype</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>fun</span> <span class='kw'>=</span> <span class='no'>dlaplace</span>,
              <span class='kw'>args</span> <span class='kw'>=</span> <span class='fu'>list</span>(<span class='kw'>location</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>scale</span> <span class='kw'>=</span> <span class='no'>scale</span>)) +
    <span class='fu'>stat_dist</span>(<span class='st'>"product_normal"</span>, <span class='kw'>size</span> <span class='kw'>=</span> <span class='fl'>.75</span>, <span class='kw'>linetype</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>fun</span> <span class='kw'>=</span> <span class='no'>dproduct_normal</span>,
              <span class='kw'>args</span> <span class='kw'>=</span> <span class='fu'>list</span>(<span class='kw'>scale</span> <span class='kw'>=</span> <span class='fl'>1</span>))
}
<span class='co'># Cauchy has fattest tails, followed by student_t, laplace, and normal</span>
<span class='fu'>compare_priors</span>()</div><img src='priors-10.png' alt='' width='540' height='400' /><div class='input'>
<span class='co'># The student_t with df = 1 is the same as the cauchy</span>
<span class='fu'>compare_priors</span>(<span class='kw'>df_t</span> <span class='kw'>=</span> <span class='fl'>1</span>)</div><img src='priors-12.png' alt='' width='540' height='400' /><div class='input'>
<span class='co'># Even a scale of 5 is somewhat large. It gives plausibility to rather </span>
<span class='co'># extreme values</span>
<span class='fu'>compare_priors</span>(<span class='kw'>scale</span> <span class='kw'>=</span> <span class='fl'>5</span>, <span class='kw'>xlim</span> <span class='kw'>=</span> <span class='fu'>c</span>(-<span class='fl'>20</span>,<span class='fl'>20</span>))</div><img src='priors-14.png' alt='' width='540' height='400' /><div class='input'>
<span class='co'># If you use a prior like normal(0, 1000) to be "non-informative" you are </span>
<span class='co'># actually saying that a coefficient value of e.g. -500 is quite plausible</span>
<span class='fu'>compare_priors</span>(<span class='kw'>scale</span> <span class='kw'>=</span> <span class='fl'>1000</span>, <span class='kw'>xlim</span> <span class='kw'>=</span> <span class='fu'>c</span>(-<span class='fl'>1000</span>,<span class='fl'>1000</span>))</div><img src='priors-16.png' alt='' width='540' height='400' /><div class='input'>
</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#value">Value</a></li>

      <li><a href="#details">Details</a></li>

      <li><a href="#references">References</a></li>

      <li><a href="#see-also">See also</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Jonah Gabry, Ben Goodrich.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
